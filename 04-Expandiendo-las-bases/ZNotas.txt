===========================================================
Componentes:
En esta carpeta irán todos los componentes que no son paginas
pueden ser desde sidebars navbars botones listas entre otros
incluye componentes compartidos, es decir, elementos que seran persistentes durante la 
navegación.
===========================================================




============================================================================
Notas:

-- En paginas no se suele usar selectores dado que: 
-- estas se renderizan dentro del router-outlet

-- En los componentes si se suelen usar dado que estos uno puede decidir donde ponerlos
============================================================================





==========================================================================================
Cambios importantes en angular:
1: ===== Desaparecio el App.Module
  En su lugar tenemos el app.config.ts
  Este archivo app.config.ts nos va a permitir hacer inyeccion de modulos o otros proveedores para tener el mismo comportamientos de antes

  Entonces anteriormente el main.ts al momento de levantar el bootstrap de la aplicacion usaba el AppModule
  ahora ya no usa el appModule si no el app.config

2:    selector: 'app-root',
      standalone: true,// se utiliza para marcar un componente como independiente. Esto significa que el componente
                          no necesita ser declarado en un módulo NgModule para funcionar.
      imports: [CommonModule, RouterOutlet],
      templateUrl: './app.component.html',
      styleUrl: './app.component.css'
    })

3: ===== AppRoute: Crea un archivo de rutas que se proveen automaticamente en el app.config tal cual como se proveee o se importa
  el modulo de rutas en el antigui appModule

4: standaloneComponent: en cada componente se utiliza para marcar un componente como independiente. Esto significa que el componente
                          no necesita ser declarado en un módulo NgModule para funcionar.
            al marcar un componente como independiente hace que la aplicacionno use ningun modulo para manejar componentes

5: Rutas: dentro del direcctorio de App se crea por defecto uno archivo llamado app.routes.ts
   y se llamaran las rutas de dos maneras
  01: loadComponent:() => import ('./dashboard/dashboard.component').then((component) => component.DashboardComponent)
  en las versiones anteriores a la 17 se cargaria o se llamaria un modulo hijo el cual tiene rutas hijas en este caso se lla un componenente hojo app.component

  02: loadComponent:() => import ('./dashboard/dashboard.component'), de esta manera tambien podemos llamar a un componente dentro de otro subdirectorio o modulo
      pero par que nos funcione el componente debe estar exportado por defecto

la forma de indicar que este componente tiene hojos es agregando  una propiedad children que vendria a ser un arreglo de rutas las cuales pertenecen
al componente que se cargará y se haaria de la siguieente manera:
 path: 'dashboard',
    loadComponent: () => import('./dashboard/dashboard.component'),
    children:[
        {

        }
    ]

    <!--  -->
6: //#agregar alias
  01. nos vamos a tsconfig.json dentro del objeto compilerOptions
  02. configuramos un arreglo en el que iran las rutas y alias que queramos agregar
    "paths": {
      "@shared/*":["./src/app/dashboard/shared/*"],
    },


7: @For === Propiedades dentro de un for en la nueva sintaxis

  @for(framework of frameWorks(); track framework; let i = $index, first = $first, last = $last, event = $even, count = $count, odd = $odd){}
  $framework: Devuelve el elemento del arreglo este nos servirá para dar seguimiento.
  $index: Devuelve el índice del elemento actual en la iteración.
  $first: Indica si el elemento actual es el primero en la iteración.
  $last:  Indica si el elemento actual es el último en la iteración.
  $even:  Indica si el índice del elemento actual es par.
  $count: Una propiedad personalizada para llevar un conteo de las iteraciones.
  $odd:   Indica si el índice del elemento actual es impar.


==========================================================================================





==========================================================================================
// Comunicación entre componentes - Nueva sintaxis:
// input: de padrea a hijo
// requerido = input.required<tipo>()
// ahora puedo indicar que los inputs son o no son requeridos en el hijo, mediante una signal y especificar el tipo 
// esto para que al momento de llamar a ese componente dentro de otro
// deva o no mandar una propiedad.

// Output:  de hijo a padre
// newCharacterEvent = output<Character>();
// ahora puedo indicar de forma sencilla que tipo de dato que voy a enviar a un elemento padre
// mediante un evento y recepcionarlo de forma cencilla mediante $event
// <dragonball-character-add (newCharacterEvent)="agregarPersonaje($event)"/>
==========================================================================================



==========================================================================================
// Servicios:
// Los servicios son fragmentos de código reutilizables que se pueden compartir en toda la aplicación Angular. 
// Suelen gestionar la obtención de datos, la lógica de negocio u otras funciones a las que varios componentes necesitan acceder
==========================================================================================

==========================================================================================
// La forma de hacer uso de estos servicios en un componente es con la siguiente sintaxis
// public dragonBallServiceIn = inject(DragonBallService); esto hace 
// inject() es una función de Angular (Angular 14+)
// Permite obtener una dependencia sin usar el constructor
// es más limpio en caso de que existan muchos servicios
==========================================================================================

==========================================================================================
// effect:
// Los effects son una herramienta de Angular Signals que sirven para ejecutar código cuando cambia una señal
// angular detecta cuando hay una señal dentro de un efecto y cada que esa señal cambia, el efecto se dispara
==========================================================================================
==========================================================================================
// Desplegar y HasRouter

// ng build:
// Construir la aplicacion en produccion

==========================================================================================


